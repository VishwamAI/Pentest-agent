from flask import Flask, request, jsonify
import requests
import concurrent.futures
import re

app = Flask(__name__)

def validate_url(url):
    pattern = re.compile(
        r'^(?:http|ftp)s?://'  # http:// or https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|'  # domain...
        r'localhost|'  # localhost...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}|'  # ...or ipv4
        r'\[?[A-F0-9]*:[A-F0-9:]+\]?)'  # ...or ipv6
        r'(?::\d+)?'  # optional port
        r'(?:/?|[/?]\S+)$', re.IGNORECASE)
    return re.match(pattern, url) is not None

def scan_sql_injection(url, user_agent):
    """
    Scans the given URL for SQL Injection vulnerabilities using common payloads.
    """
    payloads = ["' OR '1'='1", "' OR '1'='1' --", "' OR '1'='1' /*", "' OR '1'='1' #", "' OR '1'='2", "' OR '1'='3"]
    results = []
    for payload in payloads:
        try:
            test_url = f"{url}?test={payload}"
            response = requests.get(test_url, headers={"User-Agent": user_agent})
            response_time = response.elapsed.total_seconds()
            response_code = response.status_code
            if "error" in response.text or "syntax" in response.text or "SQL" in response.text:
                remediation = "Use parameterized queries or prepared statements to prevent SQL Injection. Example in Python:\n\nimport sqlite3\nconn = sqlite3.connect('example.db')\ncursor = conn.cursor()\nquery = 'SELECT * FROM users WHERE username = ?'\ncursor.execute(query, (username,))\n"
                results.append({"type": "SQL Injection", "url": test_url, "payload": payload, "status": "Potential vulnerability found", "severity": "High", "recommendation": "Sanitize and parameterize SQL queries.", "remediation": remediation, "response_time": response_time, "response_code": response_code})
                return results
        except requests.RequestException as e:
            results.append({"type": "SQL Injection", "url": test_url, "payload": payload, "status": f"Error: {e}", "response_time": 0, "response_code": 0})
    results.append({"type": "SQL Injection", "url": url, "status": "No vulnerability found", "response_time": 0, "response_code": 0})
    return results
def scan_xss(url, user_agent):
    """
    Scans the given URL for Cross-Site Scripting (XSS) vulnerabilities using common payloads.
    """
    payloads = ["<script>alert('XSS')</script>", "<img src=x onerror=alert('XSS')>", "<body onload=alert('XSS')>", "<svg onload=alert('XSS')>", "<iframe src=javascript:alert('XSS')>"]
    results = []
    for payload in payloads:
        try:
            test_url = f"{url}?test={payload}"
            response = requests.get(test_url, headers={"User-Agent": user_agent})
            response_time = response.elapsed.total_seconds()
            response_code = response.status_code
            if payload in response.text:
                remediation = "Sanitize and encode user input to prevent XSS. Example in Python using Flask:\n\nfrom flask import Flask, request, escape\napp = Flask(__name__)\n@app.route('/submit', methods=['POST'])\ndef submit():\n    user_input = request.form['input']\n    safe_input = escape(user_input)\n    return f'Safe input: {safe_input}'\n"
                results.append({"type": "XSS", "url": test_url, "payload": payload, "status": "Potential vulnerability found", "severity": "High", "recommendation": "Sanitize and encode user input.", "remediation": remediation, "response_time": response_time, "response_code": response_code})
                return results
        except requests.RequestException as e:
            results.append({"type": "XSS", "url": test_url, "payload": payload, "status": f"Error: {e}", "response_time": 0, "response_code": 0})
    results.append({"type": "XSS", "url": url, "status": "No vulnerability found", "response_time": 0, "response_code": 0})
    return results
def scan_security_misconfigurations(url, user_agent):
    """
    Scans the given URL for common security misconfigurations by checking for the presence of important security headers.
    """
    results = []
    try:
        response = requests.get(url, headers={"User-Agent": user_agent})
        response_time = response.elapsed.total_seconds()
        response_code = response.status_code
        headers = response.headers
        if 'X-Content-Type-Options' not in headers:
            remediation = "Add the X-Content-Type-Options header with the value 'nosniff'. Example in Nginx:\n\nadd_header X-Content-Type-Options 'nosniff';\n"
            results.append({"type": "Security Misconfiguration", "url": url, "header": "X-Content-Type-Options", "status": "Missing", "severity": "Medium", "recommendation": "Add the X-Content-Type-Options header with the value 'nosniff'.", "remediation": remediation, "response_time": response_time, "response_code": response_code})
        if 'X-Frame-Options' not in headers:
            remediation = "Add the X-Frame-Options header with the value 'DENY' or 'SAMEORIGIN'. Example in Nginx:\n\nadd_header X-Frame-Options 'DENY';\n"
            results.append({"type": "Security Misconfiguration", "url": url, "header": "X-Frame-Options", "status": "Missing", "severity": "Medium", "recommendation": "Add the X-Frame-Options header with the value 'DENY' or 'SAMEORIGIN'.", "remediation": remediation, "response_time": response_time, "response_code": response_code})
        if 'Content-Security-Policy' not in headers:
            remediation = "Add a Content-Security-Policy header to mitigate XSS and other attacks. Example in Nginx:\n\nadd_header Content-Security-Policy \"default-src 'self';\";\n"
            results.append({"type": "Security Misconfiguration", "url": url, "header": "Content-Security-Policy", "status": "Missing", "severity": "High", "recommendation": "Add a Content-Security-Policy header to mitigate XSS and other attacks.", "remediation": remediation, "response_time": response_time, "response_code": response_code})
        if 'Strict-Transport-Security' not in headers:
            remediation = "Add the Strict-Transport-Security header to enforce HTTPS. Example in Nginx:\n\nadd_header Strict-Transport-Security 'max-age=31536000; includeSubDomains';\n"
            results.append({"type": "Security Misconfiguration", "url": url, "header": "Strict-Transport-Security", "status": "Missing", "severity": "High", "recommendation": "Add the Strict-Transport-Security header to enforce HTTPS.", "remediation": remediation, "response_time": response_time, "response_code": response_code})
        if 'Referrer-Policy' not in headers:
            remediation = "Add the Referrer-Policy header to control the information sent in the Referer header. Example in Nginx:\n\nadd_header Referrer-Policy 'no-referrer';\n"
            results.append({"type": "Security Misconfiguration", "url": url, "header": "Referrer-Policy", "status": "Missing", "severity": "Low", "recommendation": "Add the Referrer-Policy header to control the information sent in the Referer header.", "remediation": remediation, "response_time": response_time, "response_code": response_code})
        if 'Permissions-Policy' not in headers:
            remediation = "Add the Permissions-Policy header to control the use of browser features. Example in Nginx:\n\nadd_header Permissions-Policy 'geolocation=(self)';\n"
            results.append({"type": "Security Misconfiguration", "url": url, "header": "Permissions-Policy", "status": "Missing", "severity": "Low", "recommendation": "Add the Permissions-Policy header to control the use of browser features.", "remediation": remediation, "response_time": response_time, "response_code": response_code})
    except requests.RequestException as e:
        results.append({"type": "Security Misconfiguration", "url": url, "status": f"Error: {e}", "response_time": 0, "response_code": 0})
    return results
def scan_broken_authentication(url, user_agent, login_url=None):
    """
    Scans the given URL for Broken Authentication vulnerabilities by checking for default credentials, weak lockout mechanisms, and session management flaws.
    """
    results = []
    default_credentials = [("admin", "admin"), ("admin", "password"), ("user", "user")]
    login_url = login_url or url.rstrip('/') + "/login"
    for username, password in default_credentials:
        try:
            response = requests.post(login_url, data={"username": username, "password": password}, headers={"User-Agent": user_agent}, allow_redirects=False)
            response_time = response.elapsed.total_seconds()
            response_code = response.status_code
            if response.status_code == 200 and "dashboard" in response.text:
                remediation = "Implement strong authentication mechanisms and avoid using default credentials. Example in Python using Flask:\n\nfrom flask import Flask, request\napp = Flask(__name__)\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    if username == 'admin' and password == 'admin':\n        return 'Default credentials are not allowed'\n    return 'Login successful'\n"
                results.append({"type": "Broken Authentication", "url": login_url, "credentials": (username, password), "status": "Default credentials accepted", "remediation": remediation, "response_time": response_time, "response_code": response_code})
                return results
            elif response.status_code in [301, 302] and "Location" in response.headers:
                remediation = "Implement strong authentication mechanisms and avoid using default credentials. Example in Python using Flask:\n\nfrom flask import Flask, request\napp = Flask(__name__)\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    if username == 'admin' and password == 'admin':\n        return 'Default credentials are not allowed'\n    return 'Login successful'\n"
                results.append({"type": "Broken Authentication", "url": login_url, "credentials": (username, password), "status": "Default credentials accepted", "remediation": remediation, "response_time": response_time, "response_code": response_code})
                return results
        except requests.RequestException as e:
            results.append({"type": "Broken Authentication", "url": login_url, "credentials": (username, password), "status": f"Error: {e}", "response_time": 0, "response_code": 0})
    results.append({"type": "Broken Authentication", "url": login_url, "status": "No default credentials accepted", "response_time": 0, "response_code": 0})
    return results
def scan_session_management(url, user_agent):
    """
    Scans the given URL for Session Management Schema vulnerabilities by checking for common session management flaws.
    """
    results = []
    try:
        response = requests.get(url, headers={"User-Agent": user_agent})
        response_time = response.elapsed.total_seconds()
        response_code = response.status_code
        cookies = response.headers.get('Set-Cookie')
        if not cookies:
            results.append({"type": "Session Management", "url": url, "status": "No session cookies found", "response_time": response_time, "response_code": response_code})
        else:
            for cookie in cookies.split(','):
                cookie_name = cookie.split('=')[0].strip()
                if 'secure' not in cookie.lower():
                    results.append({"type": "Session Management", "url": url, "cookie": cookie_name, "status": "Cookie not marked as secure", "response_time": response_time, "response_code": response_code})
                if 'httponly' not in cookie.lower():
                    results.append({"type": "Session Management", "url": url, "cookie": cookie_name, "status": "Cookie not marked as HttpOnly", "response_time": response_time, "response_code": response_code})
    except requests.RequestException as e:
        results.append({"type": "Session Management", "url": url, "status": f"Error: {e}", "response_time": 0, "response_code": 0})
    return results
def scan_vulnerable_components(url, user_agent):
    """
    Scans the given URL for outdated or vulnerable third-party components.
    """
    results = []
    known_vulnerable_components = {
        "jquery": ["1.12.4", "2.2.4"],
        "bootstrap": ["3.3.7", "4.0.0"],
        "angular": ["1.5.8", "1.6.6"]
    }
    try:
        response = requests.get(url, headers={"User-Agent": user_agent})
        response_time = response.elapsed.total_seconds()
        response_code = response.status_code
        page_content = response.text
        for component, versions in known_vulnerable_components.items():
            for version in versions:
                if f"{component}-{version}" in page_content:
                    results.append({"type": "Vulnerable Component", "url": url, "component": component, "version": version, "status": "Vulnerable version detected", "severity": "High", "recommendation": f"Update {component} to a secure version.", "response_time": response_time, "response_code": response_code})
    except requests.RequestException as e:
        results.append({"type": "Vulnerable Component", "url": url, "status": f"Error: {e}", "response_time": 0, "response_code": 0})
    return results
def scan_nmap(url):
    """
    Scans the given URL for open ports and services using Nmap.
    """
    import subprocess
    import time
    results = []
    try:
        # Use the Docker container's IP address directly
        docker_ip = "172.17.0.4"
        # Run Nmap scan
        nmap_command = ["nmap", "-sV", "-p", "9090", "-Pn", docker_ip]
        start_time = time.time()
        nmap_output = subprocess.check_output(nmap_command).decode('utf-8')
        response_time = time.time() - start_time
        results.append({"type": "Nmap Scan", "url": url, "output": nmap_output, "status": "Completed", "response_time": response_time, "response_code": 0})
    except subprocess.CalledProcessError as e:
        response_time = time.time() - start_time
        results.append({"type": "Nmap Scan", "url": url, "status": f"Error: {e}", "response_time": response_time, "response_code": e.returncode})
    return results
def information_gathering(url, user_agent):
    """
    Performs information gathering tasks such as search engine discovery, web server fingerprinting, and application enumeration on the given URL.
    """
    results = []
    try:
        # Commented out to avoid unauthorized external service access
        # Search Engine Discovery
        # search_engine_url = f"https://www.google.com/search?q=site:{url}"
        # response = requests.get(search_engine_url, headers={"User-Agent": user_agent})
        # response_time = response.elapsed.total_seconds()
        # response_code = response.status_code
        # if response.status_code == 200:
        #     results.append({"type": "Information Gathering", "url": url, "method": "Search Engine Discovery", "status": "Success", "response_time": response_time, "response_code": response_code})
        # else:
        #     results.append({"type": "Information Gathering", "url": url, "method": "Search Engine Discovery", "status": "Failed", "response_time": response_time, "response_code": response_code})

        # Fingerprint Web Server
        response = requests.get(url, headers={"User-Agent": user_agent})
        response_time = response.elapsed.total_seconds()
        response_code = response.status_code
        server_header = response.headers.get('Server')
        if server_header:
            results.append({"type": "Information Gathering", "url": url, "method": "Fingerprint Web Server", "server": server_header, "status": "Success", "response_time": response_time, "response_code": response_code})
        else:
            results.append({"type": "Information Gathering", "url": url, "method": "Fingerprint Web Server", "status": "Failed", "response_time": response_time, "response_code": response_code})

        # Enumerate Applications on Web Server
        common_paths = ["/admin", "/login", "/dashboard", "/api"]
        for path in common_paths:
            full_url = url.rstrip('/') + path
            response = requests.get(full_url, headers={"User-Agent": user_agent})
            response_time = response.elapsed.total_seconds()
            response_code = response.status_code
            if response.status_code == 200:
                results.append({"type": "Information Gathering", "url": full_url, "method": "Enumerate Applications", "status": "Found", "response_time": response_time, "response_code": response_code})
            else:
                results.append({"type": "Information Gathering", "url": full_url, "method": "Enumerate Applications", "status": "Not Found", "response_time": response_time, "response_code": response_code})
    except requests.RequestException as e:
        results.append({"type": "Information Gathering", "url": url, "status": f"Error: {e}", "response_time": 0, "response_code": 0})
    return results
def scan_identification_and_authentication_failures(url, user_agent):
    """
    Scans the given URL for Identification and Authentication Failures by checking for weak authentication mechanisms.
    """
    results = []
    try:
        response = requests.get(url, headers={"User-Agent": user_agent})
        response_time = response.elapsed.total_seconds()
        response_code = response.status_code
        if response.status_code == 200:
            if "login" in response.text.lower():
                results.append({"type": "Identification and Authentication Failures", "url": url, "status": "Potential vulnerability found", "severity": "High", "recommendation": "Implement strong authentication mechanisms.", "response_time": response_time, "response_code": response_code})
        else:
            results.append({"type": "Identification and Authentication Failures", "url": url, "status": "No vulnerability found", "response_time": response_time, "response_code": response_code})
    except requests.RequestException as e:
        results.append({"type": "Identification and Authentication Failures", "url": url, "status": f"Error: {e}", "response_time": 0, "response_code": 0})
    return results
def scan_software_and_data_integrity_failures(url, user_agent):
    """
    Scans the given URL for Software and Data Integrity Failures by checking for the use of known vulnerable libraries.
    """
    results = []
    try:
        response = requests.get(url, headers={"User-Agent": user_agent})
        response_time = response.elapsed.total_seconds()
        response_code = response.status_code
        if response.status_code == 200:
            if "jquery-1.12.4" in response.text:
                results.append({"type": "Software and Data Integrity Failures", "url": url, "library": "jQuery 1.12.4", "status": "Vulnerable library found", "severity": "High", "recommendation": "Update jQuery to a secure version.", "response_time": response_time, "response_code": response_code})
        else:
            results.append({"type": "Software and Data Integrity Failures", "url": url, "status": "No vulnerability found", "response_time": response_time, "response_code": response_code})
    except requests.RequestException as e:
        results.append({"type": "Software and Data Integrity Failures", "url": url, "status": f"Error: {e}", "response_time": 0, "response_code": 0})
    return results
def scan_security_logging_and_monitoring_failures(url, user_agent):
    """
    Scans the given URL for Security Logging and Monitoring Failures by checking for the presence of security logs.
    """
    results = []
    try:
        response = requests.get(url, headers={"User-Agent": user_agent})
        response_time = response.elapsed.total_seconds()
        response_code = response.status_code
        if response.status_code == 200:
            if "log" in response.text.lower():
                results.append({"type": "Security Logging and Monitoring Failures", "url": url, "status": "Potential vulnerability found", "severity": "Medium", "recommendation": "Implement comprehensive security logging and monitoring.", "response_time": response_time, "response_code": response_code})
        else:
            results.append({"type": "Security Logging and Monitoring Failures", "url": url, "status": "No vulnerability found", "response_time": response_time, "response_code": response_code})
    except requests.RequestException as e:
        results.append({"type": "Security Logging and Monitoring Failures", "url": url, "status": f"Error: {e}", "response_time": 0, "response_code": 0})
    return results
def scan_ssrf(url, user_agent):
    """
    Scans the given URL for Server-Side Request Forgery (SSRF) vulnerabilities.
    """
    results = []
    payloads = ["http://localhost:9090", "http://127.0.0.1:9090"]
    for payload in payloads:
        try:
            test_url = f"{url}?url={payload}"
            response = requests.get(test_url, headers={"User-Agent": user_agent})
            response_time = response.elapsed.total_seconds()
            response_code = response.status_code
            if response.status_code == 200 and "localhost" in response.text:
                results.append({"type": "SSRF", "url": test_url, "payload": payload, "status": "Potential vulnerability found", "severity": "High", "recommendation": "Validate and sanitize user input for URLs.", "response_time": response_time, "response_code": response_code})
                return results
        except requests.RequestException as e:
            results.append({"type": "SSRF", "url": test_url, "payload": payload, "status": f"Error: {e}", "response_time": 0, "response_code": 0})
    results.append({"type": "SSRF", "url": url, "status": "No vulnerability found", "response_time": 0, "response_code": 0})
    return results
def scan_api_vulnerabilities(url, user_agent):
    """
    Scans the given URL for API vulnerabilities by testing both REST and GraphQL APIs.
    """
    results = []
    rest_payloads = [
        {"method": "GET", "endpoint": "/api/v1/resource", "params": {"id": "1 OR 1=1"}},
        {"method": "POST", "endpoint": "/api/v1/resource", "data": {"name": "<script>alert('XSS')</script>"}}
    ]
    graphql_payloads = [
        {"query": "{ user(id: \"1 OR 1=1\") { id name } }"},
        {"query": "mutation { createUser(name: \"<script>alert('XSS')</script>\") { id name } }"}
    ]

    for payload in rest_payloads:
        try:
            if payload["method"] == "GET":
                response = requests.get(url + payload["endpoint"], params=payload["params"], headers={"User-Agent": user_agent})
            elif payload["method"] == "POST":
                response = requests.post(url + payload["endpoint"], data=payload["data"], headers={"User-Agent": user_agent})
            response_time = response.elapsed.total_seconds()
            response_code = response.status_code
            if "error" in response.text or "syntax" in response.text or "SQL" in response.text or "<script>alert('XSS')</script>" in response.text:
                results.append({"type": "API Vulnerability", "url": url + payload["endpoint"], "payload": payload, "status": "Potential vulnerability found", "severity": "High", "recommendation": "Sanitize and validate API inputs.", "response_time": response_time, "response_code": response_code})
        except requests.RequestException as e:
            results.append({"type": "API Vulnerability", "url": url + payload["endpoint"], "payload": payload, "status": f"Error: {e}", "response_time": 0, "response_code": 0})

    for payload in graphql_payloads:
        try:
            response = requests.post(url, json=payload, headers={"User-Agent": user_agent})
            response_time = response.elapsed.total_seconds()
            response_code = response.status_code
            if "error" in response.text or "syntax" in response.text or "SQL" in response.text or "<script>alert('XSS')</script>" in response.text:
                results.append({"type": "API Vulnerability", "url": url, "payload": payload, "status": "Potential vulnerability found", "severity": "High", "recommendation": "Sanitize and validate GraphQL inputs.", "response_time": response_time, "response_code": response_code})
        except requests.RequestException as e:
            results.append({"type": "API Vulnerability", "url": url, "payload": payload, "status": f"Error: {e}", "response_time": 0, "response_code": 0})

    results.append({"type": "API Vulnerability", "url": url, "status": "No vulnerability found", "response_time": 0, "response_code": 0})
    return results
def scan_url(url, user_agent, login_url=None):
    print(f"Scanning {url} for vulnerabilities...")
    results = []
    with concurrent.futures.ThreadPoolExecutor() as executor:
        futures = [
            executor.submit(information_gathering, url, user_agent),
            executor.submit(scan_sql_injection, url, user_agent),
            executor.submit(scan_xss, url, user_agent),
            executor.submit(scan_security_misconfigurations, url, user_agent),
            executor.submit(scan_broken_authentication, url, user_agent, login_url),
            executor.submit(scan_session_management, url, user_agent),
            executor.submit(scan_nmap, url),
            executor.submit(scan_vulnerable_components, url, user_agent),
            executor.submit(scan_identification_and_authentication_failures, url, user_agent),
            executor.submit(scan_software_and_data_integrity_failures, url, user_agent),
            executor.submit(scan_security_logging_and_monitoring_failures, url, user_agent),
            executor.submit(scan_ssrf, url, user_agent),
            executor.submit(scan_api_vulnerabilities, url, user_agent),
        ]
        for future in concurrent.futures.as_completed(futures):
            results.extend(future.result())
    return results

@app.route('/web_pentest', methods=['POST'])
def web_pentest():
    data = request.json
    target_url = data.get('target_url')
    user_agent = data.get('user_agent', 'PentestAgent')
    login_url = data.get('login_url')

    if not validate_url(target_url):
        return jsonify({"error": "Invalid URL"}), 400

    results = scan_url(target_url, user_agent, login_url)
    return jsonify(results)

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)

@app.route('/android_pentest', methods=['POST'])
def android_pentest():
    data = request.json
    apk_file = data.get('apk_file')
    user_agent = data.get('user_agent', 'PentestAgent')

    # Placeholder for Android pentest logic
    results = [{"type": "Android Pentest", "status": "Not implemented yet"}]
    return jsonify(results)

@app.route('/ios_pentest', methods=['POST'])
def ios_pentest():
    data = request.json
    ipa_file = data.get('ipa_file')
    user_agent = data.get('user_agent', 'PentestAgent')

    # Placeholder for iOS pentest logic
    results = [{"type": "iOS Pentest", "status": "Not implemented yet"}]
    return jsonify(results)

@app.route('/cloud_pentest', methods=['POST'])
def cloud_pentest():
    data = request.json
    cloud_service = data.get('cloud_service')
    user_agent = data.get('user_agent', 'PentestAgent')

    # Placeholder for cloud pentest logic
    results = [{"type": "Cloud Pentest", "status": "Not implemented yet"}]
    return jsonify(results)

@app.route('/llm_pentest', methods=['POST'])
def llm_pentest():
    data = request.json
    model_name = data.get('model_name')
    user_agent = data.get('user_agent', 'PentestAgent')

    # Placeholder for LLM pentest logic
    results = [{"type": "LLM Pentest", "status": "Not implemented yet"}]
    return jsonify(results)
