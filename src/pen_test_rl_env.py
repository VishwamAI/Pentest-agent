import gym
from gym import spaces
import numpy as np
import requests
import time

class PenTestEnv(gym.Env):
    """
    Custom Environment for Penetration Testing Agent
    """
    metadata = {'render.modes': ['human']}

    def __init__(self, target_url, user_agent):
        super(PenTestEnv, self).__init__()
        self.target_url = target_url
        self.user_agent = user_agent

        # Define action and observation space
        # Actions: 0 = SQL Injection, 1 = XSS, 2 = Security Misconfigurations, 3 = Broken Authentication, 4 = Session Management, 5 = Nmap Scan, 6 = Vulnerable Components, 7 = Information Gathering
        self.action_space = spaces.Discrete(8)
        # Observation space: [vulnerability_type, severity, confidence, response_time, response_code]
        self.observation_space = spaces.Box(low=0, high=1, shape=(5,), dtype=np.float32)

        # Initialize state
        self.state = None
        self.reset()

    def step(self, action):
        """
        Execute one step in the environment
        """
        assert self.action_space.contains(action), "Invalid Action"
        reward = 0
        done = False

        if action == 0:
            result, response_time, response_code = self.scan_sql_injection()
            reward = 10 if result else -1
        elif action == 1:
            result, response_time, response_code = self.scan_xss()
            reward = 8 if result else -1
        elif action == 2:
            result, response_time, response_code = self.scan_security_misconfigurations()
            reward = 5 if result else -1
        elif action == 3:
            result, response_time, response_code = self.scan_broken_authentication()
            reward = 7 if result else -1
        elif action == 4:
            result, response_time, response_code = self.scan_session_management()
            reward = 6 if result else -1
        elif action == 5:
            result, response_time, response_code = self.scan_nmap()
            reward = 4 if result else -1
        elif action == 6:
            result, response_time, response_code = self.scan_vulnerable_components()
            reward = 3 if result else -1
        elif action == 7:
            result, response_time, response_code = self.information_gathering()
            reward = 2 if result else -1

        self.state = np.array([action / 7, reward / 10, 1 if result else 0, response_time, response_code / 100], dtype=np.float32)
        return self.state, reward, done, {}

    def reset(self):
        """
        Reset the environment state
        """
        self.state = np.array([0, 0, 0, 0, 0], dtype=np.float32)
        return self.state

    def render(self, mode='human'):
        """
        Render the environment (optional)
        """
        pass

    def scan_sql_injection(self):
        payloads = ["' OR '1'='1", "' OR '1'='1' --", "' OR '1'='1' /*", "' OR '1'='1' #", "' OR '1'='2", "' OR '1'='3"]
        for payload in payloads:
            try:
                test_url = f"{self.target_url}?test={payload}"
                response = requests.get(test_url, headers={"User-Agent": self.user_agent})
                response_time = response.elapsed.total_seconds()
                response_code = response.status_code
                if "error" in response.text or "syntax" in response.text or "SQL" in response.text:
                    return True, response_time, response_code
            except requests.RequestException:
                return False, 0, 0
        return False, 0, 0

    def scan_xss(self):
        payloads = ["<script>alert('XSS')</script>", "<img src=x onerror=alert('XSS')>", "<body onload=alert('XSS')>", "<svg onload=alert('XSS')>", "<iframe src=javascript:alert('XSS')>"]
        for payload in payloads:
            try:
                test_url = f"{self.target_url}?test={payload}"
                response = requests.get(test_url, headers={"User-Agent": self.user_agent})
                response_time = response.elapsed.total_seconds()
                response_code = response.status_code
                if payload in response.text:
                    return True, response_time, response_code
            except requests.RequestException:
                return False, 0, 0
        return False, 0, 0

    def scan_security_misconfigurations(self):
        try:
            response = requests.get(self.target_url, headers={"User-Agent": self.user_agent})
            response_time = response.elapsed.total_seconds()
            response_code = response.status_code
            headers = response.headers
            if 'X-Content-Type-Options' not in headers or 'X-Frame-Options' not in headers or 'Content-Security-Policy' not in headers or 'Strict-Transport-Security' not in headers or 'Referrer-Policy' not in headers or 'Permissions-Policy' not in headers:
                return True, response_time, response_code
        except requests.RequestException:
            return False, 0, 0
        return False, 0, 0

    def scan_broken_authentication(self):
        default_credentials = [("admin", "admin"), ("admin", "password"), ("user", "user")]
        login_url = self.target_url.rstrip('/') + "/login"
        for username, password in default_credentials:
            try:
                response = requests.post(login_url, data={"username": username, "password": password}, headers={"User-Agent": self.user_agent}, allow_redirects=False)
                response_time = response.elapsed.total_seconds()
                response_code = response.status_code
                if response.status_code == 200 and "dashboard" in response.text:
                    return True, response_time, response_code
                elif response.status_code in [301, 302] and "Location" in response.headers:
                    return True, response_time, response_code
            except requests.RequestException:
                return False, 0, 0
        return False, 0, 0

    def scan_session_management(self):
        try:
            response = requests.get(self.target_url, headers={"User-Agent": self.user_agent})
            response_time = response.elapsed.total_seconds()
            response_code = response.status_code
            cookies = response.headers.get('Set-Cookie')
            if not cookies:
                return False, response_time, response_code
            for cookie in cookies.split(','):
                if 'secure' not in cookie.lower() or 'httponly' not in cookie.lower():
                    return True, response_time, response_code
        except requests.RequestException:
            return False, 0, 0
        return False, 0, 0

    def scan_nmap(self):
        import subprocess
        try:
            docker_ip = "172.17.0.4"
            nmap_command = ["nmap", "-sV", "-p", "9090", "-Pn", docker_ip]
            start_time = time.time()
            output = subprocess.check_output(nmap_command).decode('utf-8')
            response_time = time.time() - start_time
            response_code = 0  # Nmap does not have an HTTP response code
            return True, response_time, response_code
        except subprocess.CalledProcessError:
            return False, 0, 0

    def scan_vulnerable_components(self):
        known_vulnerable_components = {
            "jquery": ["1.12.4", "2.2.4"],
            "bootstrap": ["3.3.7", "4.0.0"],
            "angular": ["1.5.8", "1.6.6"]
        }
        try:
            response = requests.get(self.target_url, headers={"User-Agent": self.user_agent})
            response_time = response.elapsed.total_seconds()
            response_code = response.status_code
            page_content = response.text
            for component, versions in known_vulnerable_components.items():
                for version in versions:
                    if f"{component}-{version}" in page_content:
                        return True, response_time, response_code
        except requests.RequestException:
            return False, 0, 0
        return False, 0, 0

    def information_gathering(self):
        try:
            response = requests.get(self.target_url, headers={"User-Agent": self.user_agent})
            response_time = response.elapsed.total_seconds()
            response_code = response.status_code
            if response.status_code == 200:
                return True, response_time, response_code
        except requests.RequestException:
            return False, 0, 0
        return False, 0, 0

import random

class QLearningAgent:
    def __init__(self, env, learning_rate=0.1, discount_factor=0.99, epsilon=0.1):
        self.env = env
        self.learning_rate = learning_rate
        self.discount_factor = discount_factor
        self.epsilon = epsilon
        self.q_table = np.zeros((env.observation_space.shape[0], env.action_space.n))

    def choose_action(self, state):
        if random.uniform(0, 1) < self.epsilon:
            return self.env.action_space.sample()
        else:
            return np.argmax(self.q_table[state])

    def update_q_table(self, state, action, reward, next_state):
        best_next_action = np.argmax(self.q_table[next_state])
        td_target = reward + self.discount_factor * self.q_table[next_state][best_next_action]
        td_error = td_target - self.q_table[state][action]
        self.q_table[state][action] += self.learning_rate * td_error

    def train(self, num_episodes):
        for episode in range(num_episodes):
            state = self.env.reset()
            done = False
            while not done:
                action = self.choose_action(state)
                next_state, reward, done, _ = self.env.step(action)
                self.update_q_table(state, action, reward, next_state)
                state = next_state

# Example usage
if __name__ == "__main__":
    target_url = "http://localhost:9090/WebGoat"
    user_agent = "Devin/1.0"
    env = PenTestEnv(target_url, user_agent)
    agent = QLearningAgent(env)
    agent.train(num_episodes=1000)
